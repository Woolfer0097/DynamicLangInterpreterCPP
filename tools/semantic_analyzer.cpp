#include <fstream>
#include <iostream>
#include <sstream>
#include <string>
#include "lexer/lexer.hpp"
#include "lexer/parser.hpp" // generated by bison
#include "ast/ASTNode.hpp"
#include "ast/SemanticAnalyzer.hpp"
#include "tools/AstPrettyPrinter.hpp"

namespace dli { extern std::shared_ptr<ASTNode> g_root; }

int main(int argc, char** argv) {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    std::string source;
    if (argc > 1) {
        std::ifstream in(argv[1]);
        if (!in) { std::cerr << "Cannot open file: " << argv[1] << "\n"; return 1; }
        std::ostringstream ss; ss << in.rdbuf(); source = ss.str();
    } else {
        std::ostringstream ss; ss << std::cin.rdbuf(); source = ss.str();
    }

    dli::Lexer lx(source);
    dli::Parser parser(lx);
    int rc = parser.parse();
    if (rc != 0 || !dli::g_root) {
        std::cerr << "Parse failed with code " << rc << "\n";
        return 2;
    }

    // Семантические проверки (не модифицируют AST)
    dli::SemanticChecker checker;
    dli::g_root->accept(checker);
    
    if (!checker.errors.empty()) {
        std::cerr << "Semantic errors found:\n";
        for (const auto& error : checker.errors) {
            std::cerr << "  " << error << "\n";
        }
        return 3;
    }
    
    std::cout << "Semantic checks passed.\n";

    // Семантические оптимизации (модифицируют AST)
    dli::SemanticOptimizer optimizer;
    dli::g_root->accept(optimizer);
    
    if (optimizer.modified) {
        std::cout << "AST was optimized.\n";
    } else {
        std::cout << "No optimizations applied.\n";
    }

    // Выводим оптимизированный AST
    dli::AstPrettyPrinter pp(std::cout);
    std::cout << "\nOptimized AST:\n";
    dli::g_root->accept(pp);
    
    return 0;
}

