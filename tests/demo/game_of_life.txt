// Demo: Conway's Game of Life
// 5x5 grid, several generations

print "=== Game of Life Demo ==="

var rows := 20
var cols := 20

// 1 = alive, 0 = dead
// Build a rows x cols grid filled with zeros.
var grid := []
for r in 1..rows loop
    grid[r] := []
    for c in 1..cols loop
        grid[r][c] := 0
    end
end

// Helper: place a glider with its top cell at (r, c)
var place_glider := func(g, r, c) is
    // Pattern:
    // . # .
    // . . #
    // # # #
    g[r + 0][c + 1] := 1
    g[r + 1][c + 2] := 1
    g[r + 2][c + 0] := 1
    g[r + 2][c + 1] := 1
    g[r + 2][c + 2] := 1
end

// Seed a single glider in the middle of the field (to avoid collisions)
// На торе он будет бесконечно двигаться по диагонали.
place_glider(grid, 5, 5)

// Wrap helper for toroidal grid: 1..max, then back to 1
var wrap := func(x, max) is
    if x < 1 then
        return max
    else
        if x > max then
            return 1
        else
            return x
        end
    end
end

// Count alive neighbors around (r, c) on a toroidal (wrap-around) grid
var alive_neighbors := func(g, r, c, rows, cols) is
    var count := 0

    var r_up := wrap(r - 1, rows)
    var r_down := wrap(r + 1, rows)
    var c_left := wrap(c - 1, cols)
    var c_right := wrap(c + 1, cols)

    // 4 orthogonal neighbors
    if g[r_up][c] == 1 then
        count := count + 1
    end
    if g[r_down][c] == 1 then
        count := count + 1
    end
    if g[r][c_left] == 1 then
        count := count + 1
    end
    if g[r][c_right] == 1 then
        count := count + 1
    end

    // 4 diagonal neighbors
    if g[r_up][c_left] == 1 then
        count := count + 1
    end
    if g[r_up][c_right] == 1 then
        count := count + 1
    end
    if g[r_down][c_left] == 1 then
        count := count + 1
    end
    if g[r_down][c_right] == 1 then
        count := count + 1
    end

    return count
end

var print_grid := func(g, rows, cols) is
    for r in 1..rows loop
        var line := ""
        for c in 1..cols loop
            if g[r][c] == 1 then
                line := line + "#"
            else
                line := line + "."
            end
        end
        print line
    end
end

var clear_screen := func() is
    for i in 1..40 loop
        print ""
    end
end

// One step of Game of Life
var step := func(g, rows, cols) is
    var new_grid := []
    for r in 1..rows loop
        new_grid[r] := []
        for c in 1..cols loop
            var n := alive_neighbors(g, r, c, rows, cols)
            var cell := g[r][c]
            // Rules:
            // - live cell with 2 or 3 neighbors survives
            // - dead cell with 3 neighbors becomes alive
            // - otherwise dead
            if cell == 1 then
                if n == 2 then
                    new_grid[r][c] := 1
                else
                    if n == 3 then
                        new_grid[r][c] := 1
                    else
                        new_grid[r][c] := 0
                    end
                end
            else
                if n == 3 then
                    new_grid[r][c] := 1
                else
                    new_grid[r][c] := 0
                end
            end
        end
    end
    return new_grid
end

// Animated loop: перерисовываем поле в терминале
var generations := 200

for gen in 0..generations loop
    clear_screen()

    if gen == 0 then
        print "Initial generation:"
    else
        print "Generation", gen, ":"
    end

    print_grid(grid, rows, cols)

    // после последнего поколения можно не считать следующее
    if gen < generations then
        grid := step(grid, rows, cols)
    end
end

print "=== Demo Complete ==="